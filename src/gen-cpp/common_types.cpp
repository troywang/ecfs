/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "common_types.h"



const char* DatanodeEndpoint::ascii_fingerprint = "20CDC9D979DE694980EA2466496D8E68";
const uint8_t DatanodeEndpoint::binary_fingerprint[16] = {0x20,0xCD,0xC9,0xD9,0x79,0xDE,0x69,0x49,0x80,0xEA,0x24,0x66,0x49,0x6D,0x8E,0x68};

uint32_t DatanodeEndpoint::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ipv4 = false;
  bool isset_port = false;
  bool isset_nodeid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ipv4);
          isset_ipv4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->nodeid);
          isset_nodeid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ipv4)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nodeid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DatanodeEndpoint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DatanodeEndpoint");
  xfer += oprot->writeFieldBegin("ipv4", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ipv4);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->port);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("nodeid", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->nodeid);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ThriftResult::ascii_fingerprint = "96705E9A3FD7B072319C71653E0DBB90";
const uint8_t ThriftResult::binary_fingerprint[16] = {0x96,0x70,0x5E,0x9A,0x3F,0xD7,0xB0,0x72,0x31,0x9C,0x71,0x65,0x3E,0x0D,0xBB,0x90};

uint32_t ThriftResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->verbose);
          this->__isset.verbose = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThriftResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftResult");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.verbose) {
    xfer += oprot->writeFieldBegin("verbose", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->verbose);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* FileWriteToken::ascii_fingerprint = "417159561947AFE9D6FAB9AED700BE08";
const uint8_t FileWriteToken::binary_fingerprint[16] = {0x41,0x71,0x59,0x56,0x19,0x47,0xAF,0xE9,0xD6,0xFA,0xB9,0xAE,0xD7,0x00,0xBE,0x08};

uint32_t FileWriteToken::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_blockid = false;
  bool isset_chunkids = false;
  bool isset_endpoints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blockid);
          isset_blockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->chunkids.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            iprot->readListBegin(_etype3, _size0);
            this->chunkids.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readI32(this->chunkids[_i4]);
            }
            iprot->readListEnd();
          }
          isset_chunkids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->endpoints.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            iprot->readListBegin(_etype8, _size5);
            this->endpoints.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += this->endpoints[_i9].read(iprot);
            }
            iprot->readListEnd();
          }
          isset_endpoints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_blockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_chunkids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_endpoints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t FileWriteToken::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("FileWriteToken");
  xfer += oprot->writeFieldBegin("blockid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->blockid);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("chunkids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->chunkids.size()));
    std::vector<int32_t> ::const_iterator _iter10;
    for (_iter10 = this->chunkids.begin(); _iter10 != this->chunkids.end(); ++_iter10)
    {
      xfer += oprot->writeI32((*_iter10));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("endpoints", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->endpoints.size()));
    std::vector<DatanodeEndpoint> ::const_iterator _iter11;
    for (_iter11 = this->endpoints.begin(); _iter11 != this->endpoints.end(); ++_iter11)
    {
      xfer += (*_iter11).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* FileReadToken::ascii_fingerprint = "BFDAF9305445EF65B35E937060EE9443";
const uint8_t FileReadToken::binary_fingerprint[16] = {0xBF,0xDA,0xF9,0x30,0x54,0x45,0xEF,0x65,0xB3,0x5E,0x93,0x70,0x60,0xEE,0x94,0x43};

uint32_t FileReadToken::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_chunkids = false;
  bool isset_endpoints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->chunkids.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            iprot->readListBegin(_etype15, _size12);
            this->chunkids.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += iprot->readI32(this->chunkids[_i16]);
            }
            iprot->readListEnd();
          }
          isset_chunkids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->endpoints.clear();
            uint32_t _size17;
            ::apache::thrift::protocol::TType _etype20;
            iprot->readListBegin(_etype20, _size17);
            this->endpoints.resize(_size17);
            uint32_t _i21;
            for (_i21 = 0; _i21 < _size17; ++_i21)
            {
              xfer += this->endpoints[_i21].read(iprot);
            }
            iprot->readListEnd();
          }
          isset_endpoints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_chunkids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_endpoints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t FileReadToken::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("FileReadToken");
  xfer += oprot->writeFieldBegin("chunkids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->chunkids.size()));
    std::vector<int32_t> ::const_iterator _iter22;
    for (_iter22 = this->chunkids.begin(); _iter22 != this->chunkids.end(); ++_iter22)
    {
      xfer += oprot->writeI32((*_iter22));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("endpoints", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->endpoints.size()));
    std::vector<DatanodeEndpoint> ::const_iterator _iter23;
    for (_iter23 = this->endpoints.begin(); _iter23 != this->endpoints.end(); ++_iter23)
    {
      xfer += (*_iter23).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* FileRecoverToken::ascii_fingerprint = "00D98B57963D0B9CE31C9F0F53403AFB";
const uint8_t FileRecoverToken::binary_fingerprint[16] = {0x00,0xD9,0x8B,0x57,0x96,0x3D,0x0B,0x9C,0xE3,0x1C,0x9F,0x0F,0x53,0x40,0x3A,0xFB};

uint32_t FileRecoverToken::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_endpoints = false;
  bool isset_chunkids = false;
  bool isset_blockid = false;
  bool isset_oldchunk = false;
  bool isset_newchunk = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->endpoints.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _etype27;
            iprot->readListBegin(_etype27, _size24);
            this->endpoints.resize(_size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              xfer += this->endpoints[_i28].read(iprot);
            }
            iprot->readListEnd();
          }
          isset_endpoints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->chunkids.clear();
            uint32_t _size29;
            ::apache::thrift::protocol::TType _etype32;
            iprot->readListBegin(_etype32, _size29);
            this->chunkids.resize(_size29);
            uint32_t _i33;
            for (_i33 = 0; _i33 < _size29; ++_i33)
            {
              xfer += iprot->readI32(this->chunkids[_i33]);
            }
            iprot->readListEnd();
          }
          isset_chunkids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blockid);
          isset_blockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->oldchunk);
          isset_oldchunk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->newchunk);
          isset_newchunk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_endpoints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_chunkids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_blockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_oldchunk)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_newchunk)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t FileRecoverToken::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("FileRecoverToken");
  xfer += oprot->writeFieldBegin("endpoints", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->endpoints.size()));
    std::vector<DatanodeEndpoint> ::const_iterator _iter34;
    for (_iter34 = this->endpoints.begin(); _iter34 != this->endpoints.end(); ++_iter34)
    {
      xfer += (*_iter34).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("chunkids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->chunkids.size()));
    std::vector<int32_t> ::const_iterator _iter35;
    for (_iter35 = this->chunkids.begin(); _iter35 != this->chunkids.end(); ++_iter35)
    {
      xfer += oprot->writeI32((*_iter35));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("blockid", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->blockid);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("oldchunk", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->oldchunk);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("newchunk", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->newchunk);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ResultGetWriteToken::ascii_fingerprint = "F3C754971DB6A8E0F6C1A655C6F485F0";
const uint8_t ResultGetWriteToken::binary_fingerprint[16] = {0xF3,0xC7,0x54,0x97,0x1D,0xB6,0xA8,0xE0,0xF6,0xC1,0xA6,0x55,0xC6,0xF4,0x85,0xF0};

uint32_t ResultGetWriteToken::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result = false;
  bool isset_token = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->token.read(iprot);
          isset_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_token)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResultGetWriteToken::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ResultGetWriteToken");
  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->token.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ResultFixWriteToken::ascii_fingerprint = "F3C754971DB6A8E0F6C1A655C6F485F0";
const uint8_t ResultFixWriteToken::binary_fingerprint[16] = {0xF3,0xC7,0x54,0x97,0x1D,0xB6,0xA8,0xE0,0xF6,0xC1,0xA6,0x55,0xC6,0xF4,0x85,0xF0};

uint32_t ResultFixWriteToken::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result = false;
  bool isset_token = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->token.read(iprot);
          isset_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_token)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResultFixWriteToken::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ResultFixWriteToken");
  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->token.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ResultGetReadToken::ascii_fingerprint = "9DD198F1076354724B23934EDD179145";
const uint8_t ResultGetReadToken::binary_fingerprint[16] = {0x9D,0xD1,0x98,0xF1,0x07,0x63,0x54,0x72,0x4B,0x23,0x93,0x4E,0xDD,0x17,0x91,0x45};

uint32_t ResultGetReadToken::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result = false;
  bool isset_token = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->token.read(iprot);
          isset_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_token)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResultGetReadToken::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ResultGetReadToken");
  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->token.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ResultGetNodeInfo::ascii_fingerprint = "683A2F7B1A60A645E8D67BC5769C877F";
const uint8_t ResultGetNodeInfo::binary_fingerprint[16] = {0x68,0x3A,0x2F,0x7B,0x1A,0x60,0xA6,0x45,0xE8,0xD6,0x7B,0xC5,0x76,0x9C,0x87,0x7F};

uint32_t ResultGetNodeInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result = false;
  bool isset_endpoint = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->endpoint.read(iprot);
          isset_endpoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_endpoint)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResultGetNodeInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ResultGetNodeInfo");
  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("endpoint", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->endpoint.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ResultFixRecoverToken::ascii_fingerprint = "E63F4E49238490BACD4B847C980C819A";
const uint8_t ResultFixRecoverToken::binary_fingerprint[16] = {0xE6,0x3F,0x4E,0x49,0x23,0x84,0x90,0xBA,0xCD,0x4B,0x84,0x7C,0x98,0x0C,0x81,0x9A};

uint32_t ResultFixRecoverToken::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result = false;
  bool isset_token = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->token.read(iprot);
          isset_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_token)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResultFixRecoverToken::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ResultFixRecoverToken");
  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->token.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* DatanodeHeartbeat::ascii_fingerprint = "761DA4D6DC65FA18F7AFCC175BC54E81";
const uint8_t DatanodeHeartbeat::binary_fingerprint[16] = {0x76,0x1D,0xA4,0xD6,0xDC,0x65,0xFA,0x18,0xF7,0xAF,0xCC,0x17,0x5B,0xC5,0x4E,0x81};

uint32_t DatanodeHeartbeat::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_endpoint = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->endpoint.read(iprot);
          isset_endpoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_endpoint)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DatanodeHeartbeat::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DatanodeHeartbeat");
  xfer += oprot->writeFieldBegin("endpoint", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->endpoint.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* RecoveryHeartbeat::ascii_fingerprint = "01B77A1E864D2179E0D9471EEB3DA6F4";
const uint8_t RecoveryHeartbeat::binary_fingerprint[16] = {0x01,0xB7,0x7A,0x1E,0x86,0x4D,0x21,0x79,0xE0,0xD9,0x47,0x1E,0xEB,0x3D,0xA6,0xF4};

uint32_t RecoveryHeartbeat::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_endpoint = false;
  bool isset_load = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->endpoint.read(iprot);
          isset_endpoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->load);
          isset_load = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_endpoint)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_load)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RecoveryHeartbeat::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RecoveryHeartbeat");
  xfer += oprot->writeFieldBegin("endpoint", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->endpoint.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("load", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->load);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ResultGetChunk::ascii_fingerprint = "6ECF9D78DCC8499EA07DE1A8B0F26B3E";
const uint8_t ResultGetChunk::binary_fingerprint[16] = {0x6E,0xCF,0x9D,0x78,0xDC,0xC8,0x49,0x9E,0xA0,0x7D,0xE1,0xA8,0xB0,0xF2,0x6B,0x3E};

uint32_t ResultGetChunk::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result = false;
  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResultGetChunk::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ResultGetChunk");
  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ResultGetCode::ascii_fingerprint = "6ECF9D78DCC8499EA07DE1A8B0F26B3E";
const uint8_t ResultGetCode::binary_fingerprint[16] = {0x6E,0xCF,0x9D,0x78,0xDC,0xC8,0x49,0x9E,0xA0,0x7D,0xE1,0xA8,0xB0,0xF2,0x6B,0x3E};

uint32_t ResultGetCode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result = false;
  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResultGetCode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ResultGetCode");
  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ResultReadData::ascii_fingerprint = "6ECF9D78DCC8499EA07DE1A8B0F26B3E";
const uint8_t ResultReadData::binary_fingerprint[16] = {0x6E,0xCF,0x9D,0x78,0xDC,0xC8,0x49,0x9E,0xA0,0x7D,0xE1,0xA8,0xB0,0xF2,0x6B,0x3E};

uint32_t ResultReadData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result = false;
  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResultReadData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ResultReadData");
  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ResultReportChunks::ascii_fingerprint = "2349343F5FB03F96FA2E204A54D8CBE1";
const uint8_t ResultReportChunks::binary_fingerprint[16] = {0x23,0x49,0x34,0x3F,0x5F,0xB0,0x3F,0x96,0xFA,0x2E,0x20,0x4A,0x54,0xD8,0xCB,0xE1};

uint32_t ResultReportChunks::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result = false;
  bool isset_chunkInUse = false;
  bool isset_chunkUnUse = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->chunkInUse.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            iprot->readSetBegin(_etype39, _size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              int32_t _elem41;
              xfer += iprot->readI32(_elem41);
              this->chunkInUse.insert(_elem41);
            }
            iprot->readSetEnd();
          }
          isset_chunkInUse = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->chunkUnUse.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            iprot->readSetBegin(_etype45, _size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              int32_t _elem47;
              xfer += iprot->readI32(_elem47);
              this->chunkUnUse.insert(_elem47);
            }
            iprot->readSetEnd();
          }
          isset_chunkUnUse = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_chunkInUse)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_chunkUnUse)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResultReportChunks::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ResultReportChunks");
  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("chunkInUse", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->chunkInUse.size()));
    std::set<int32_t> ::const_iterator _iter48;
    for (_iter48 = this->chunkInUse.begin(); _iter48 != this->chunkInUse.end(); ++_iter48)
    {
      xfer += oprot->writeI32((*_iter48));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("chunkUnUse", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->chunkUnUse.size()));
    std::set<int32_t> ::const_iterator _iter49;
    for (_iter49 = this->chunkUnUse.begin(); _iter49 != this->chunkUnUse.end(); ++_iter49)
    {
      xfer += oprot->writeI32((*_iter49));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ResultGetBlocks::ascii_fingerprint = "43EF4D6B62529D59114D31A8C9141EA4";
const uint8_t ResultGetBlocks::binary_fingerprint[16] = {0x43,0xEF,0x4D,0x6B,0x62,0x52,0x9D,0x59,0x11,0x4D,0x31,0xA8,0xC9,0x14,0x1E,0xA4};

uint32_t ResultGetBlocks::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result = false;
  bool isset_blockids = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->blockids.clear();
            uint32_t _size50;
            ::apache::thrift::protocol::TType _etype53;
            iprot->readSetBegin(_etype53, _size50);
            uint32_t _i54;
            for (_i54 = 0; _i54 < _size50; ++_i54)
            {
              int32_t _elem55;
              xfer += iprot->readI32(_elem55);
              this->blockids.insert(_elem55);
            }
            iprot->readSetEnd();
          }
          isset_blockids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_blockids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResultGetBlocks::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ResultGetBlocks");
  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("blockids", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->blockids.size()));
    std::set<int32_t> ::const_iterator _iter56;
    for (_iter56 = this->blockids.begin(); _iter56 != this->blockids.end(); ++_iter56)
    {
      xfer += oprot->writeI32((*_iter56));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


